*** MP 3 BY ETHAN LONG AND JACOB MAYHEW ***

******  Start fetch cycle *****
 st = 0	rt = '[pc] -> mar'	imar rac = 1 rn = 3
 st = 1	rt = '[[mar]] -> mdr'	read
 st = 2	rt = '[mdr] -> ir'	iir omdr
 st = 3	rt = '[pc]+1 -> q'	rac = 1 rn = 3 ib oadder p1
 st = 4	rt = '[q] -> pc'		oq wac = 1 wn = 3
	cond = 'ir1512' value = 0 nst = 20
 cond = 'ir158'  value = 0 nst = 10
	nst = 200


****	Halt *****
 st = 10 halt

******     Single Operand Instruction   *******

*** START *****
 st = 20
 cond = 'ir64' value = 0 nst = 30
 cond = 'ir64' value = 1 nst = 40
 cond = 'ir64' value = 2 nst = 45
 cond = 'ir64' value = 3 nst = 50
 cond = 'ir64' value = 4 nst = 85
 cond = 'ir64' value = 5 nst = 85
      nst = 0

*** register ***
 st = 30 rt = '[dst]-> t5' 		it5 rac = 3 
       nst = 190

*** register indirect ***
 st = 40 rt = '[dst]  -> t4'    	it4 rac = 3 
       nst = 80

*** autoinc ***
 st = 45 rt = '[dst]  -> t4'    	it4 rac = 3
 st = 46 rt = '[dst]+1-> q'  	      rac = 3 ib oadder p1
 st = 47 rt = '[q]    -> dst'     	oq wac = 3   
       nst = 80

*** autodec ***
 st = 50 rt = '[dst]  -> t1'   	rac = 3 it1 
 st = 51 rt = '[t1]-1 -> q'   	oadder oa comp  
 st = 52 rt = '[q]    -> dst'    	wac = 3 oq  
 st = 53 rt = '[dst]  -> t4'   	rac = 3 it4    
       nst = 80
      
*** index ***
 st = 55 rt = '[mdr]  -> t1'   	it1 omdr
 st = 56 rt = '[t1]+[dst]-> q' 	rac = 3 ib oa oadder
 st = 57 rt = '[q]    -> t4'     	it4 oq
       nst = 80

*** absolute ***
 st = 60 rt = '[mdr]  -> t4'   	omdr it4  
       nst = 80

*** read in dest from memory ***
 st = 80 rt = '[t4]   -> mar' 	imar ot4 
 st = 81 rt = '[[mar]]-> mdr' 	read
 st = 82 rt = '[mdr]  -> t5' 	      omdr it5 
       nst = 190

*** fetch ***
 st = 85 rt = '[pc]   -> mar'  	rac = 1 rn = 3 imar
 st = 86 rt = '[[mar]]-> mdr'       read
 st = 87 rt = '[pc]+1 -> q'  	      rac = 1 rn = 3 oadder p1 ib
 st = 88 rt = '[q]    -> pc'    	wac = 1 wn = 3 oq 
  cond = 'ir64' value = 4 nst = 55
  cond = 'ir64' value = 5 nst = 60

*** single instructions ***
 st = 100
  cond = 'ir118' value = 2 nst = 110
  cond = 'ir118' value = 3 nst = 120
       nst = 10 

*** inc ***
 st = 110 rt = '[t5]   -> t1' 	it1 ot5 
 st = 111 rt = '[t1]+1 -> q' 	      oadder p1 oa newv newc 
 st = 112 rt = '[q]    -> t2' 	it2 oq 
       nst = 140

*** dec ***
 st = 120 rt = '[t5]   -> t1' 	it1 ot5 
 st = 121 rt = '[t1]-1 -> q' 	      oadder comp newv newc oa 
 st = 122 rt = '[q]    -> t2' 	it2 oq 
       nst = 140

*** neg ***

 st = 125 rt = '[t5]   -> t1'     it1 ot5
 st = 126 rt = '0-[t1] -> q' 	    ib comp p1 newv newc ot5 oadder
 st = 127 rt = '[q]    -> t2'     it2 oq
       nst = 140

*** write ***
 st = 140
  cond = 'ir64' value = 0 nst = 150
  cond = 'ir64' value = 1 nst = 160
  cond = 'ir64' value = 2 nst = 160
  cond = 'ir64' value = 3 nst = 160
  cond = 'ir64' value = 4 nst = 160
  cond = 'ir64' value = 5 nst = 160

*** register mode ***
 st = 150 rt = '[t2]  -> dst' 	wac = 3 ot2 newn newz 
       nst = 0

*** dst to memory ***
 st = 160 rt = '[t4]  -> mar' 	imar ot4 
 st = 161 rt = '[t2]  -> mdr' 	imdr ot2 newz newn
 st = 162 rt = '[mdr] -> [mar]' 	write
       nst = 0


*** select double or single ***
 st = 190
  cond = 'ir1512' value = 0 nst = 100
  cond = 'ir1512' value = 1 nst = 250
  cond = 'ir1512' value = 1 nst = 260
  cond = 'ir1512' value = 3 nst = 271
       nst = 140




*** read src from memory for double instructions ***
 st = 195 rt = '[t3]   -> mar' 	imar ot3 
 st = 196 rt = '[[mar]]-> mdr' 	read
 st = 197 rt = '[mdr]  -> t2' 	omdr it2  
       nst = 20

*** select addressing mode ***
 st = 200
 cond = 'ir118' value = 0 nst = 210
 cond = 'ir118' value = 1 nst = 215
 cond = 'ir118' value = 2 nst = 220
 cond = 'ir118' value = 3 nst = 225
 cond = 'ir118' value = 4 nst = 245
 cond = 'ir118' value = 5 nst = 245
 cond = 'ir118' value = 6 nst = 245
     
*** register for double inst ***
 st = 210 rt = '[src]  -> t2'    	rac = 2 it2
       nst = 20

*** register indirect for double inst ***
 st = 215 rt = '[src]  -> t3'    	rac = 2 it3
       nst = 195

*** autoinc for double inst ***
 st = 220 rt = '[src]  -> t3'    	rac = 2 it3
 st = 221 rt = '[src]+1-> q'   	rac = 2 ib oadder p1
 st = 222 rt = '[q]    -> src'	wac = 2 oq
       nst = 195

*** autodec for double inst ***
 st = 225 rt = '[src]  -> t1'    	rac = 2 it1
 st = 226 rt = '[t1]-1 -> q'    	oa comp oadder
 st = 227 rt = '[q]    -> src'      wac = 2 oq
 st = 228 rt = '[src]  -> t3'    	rac = 2 it3
       nst = 195

*** index for double inst ***
 st = 230 rt = '[mdr]  -> t1'    	it1 omdr
 st = 231 rt = '[t1]+[src]->q'	rac = 2 ib oa oadder
 st = 232 rt = '[q]    -> t3'      	oq it3  
       nst = 195

*** absolute for double inst ***
 st = 235 rt = '[mdr]  -> t3'    	it3 omdr
       nst = 195

*** immediate for double inst ***
 st = 240 rt = '[mdr]  -> t2'    	it2 omdr
       nst = 20

*** fetch for src ***
 st = 245 rt = '[pc]   -> mar'    	rac = 1 rn = 3 imar 
 st = 246 rt = '[[mar]]-> mdr' 	read
 st = 247 rt = '[pc]+1 -> q'    	rac = 1 rn = 3 oadder p1 ib
 st = 248 rt = '[q]    -> pc'      	wac = 1 wn = 3 oq 
  cond = 'ir118' value = 4 nst = 230
  cond = 'ir118' value = 5 nst = 235
  cond = 'ir118' value = 6 nst = 240

*** double instructions ***

*** add **
 st = 250 rt = '[t2]   -> t1' 	it1 ot2 
 st = 251 rt = '[t5]+[t1]->q' 	oadder oa newv newc ib ot5
 st = 252 rt = '[q]    -> t2' 	it2 oq 
       nst = 140

*** sub ***

*** move ***
 st=260 rt='[T3] -> T1' it1 ot3
 st=261 rt='[T1] -> T2' it2 it1
       nst=90
